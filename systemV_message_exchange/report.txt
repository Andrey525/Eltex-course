##########################################################################################
Функция key_t ftok(const char* pathname, int proj_id). Для создания ключа...что за ключ и зачем он нужен? читаем дальше...
    * Первым аргументом передаем имя файла (файл должен существовать и быть доступным).
    * Вторым аргументом передаем идентификатор проекта (используются только младшие 8 бит, поэтому
        несмотря на то, что тип значения int, принято передавать туда символ char, так как
            sizeof(char) == 1 байт == 8 бит).
    * На основе pathname и proj_id функция создает ключ и возвращает его. Если ошибка, возвращает -1.
        Этот ключ понадобится для вызовов msgget(функция для создания или присоединения к очереди сообщений), 
            semget(семафоры для разделямой памяти), и shmget(разделяемая память). Нас интересует только msgget.
                semget и shmget составляют другой механизм межпроцессорного взаимодейсвия.
    **Ключ одинаков только в том случае, если указан один и тот же файл и один и тот же proj_id.
        В файл ничего не пишется, интересует именно его уникальный inode (как я понял).

##########################################################################################
Функция int msgget (key_t key, int msg_flags). Для создания либо подключения к очереди.
    * Первым аргументом передаем ключ, полученный с помощью ftok(), либо специальный ключ IPC_PRIVATE.
        В втором случае создается локальная приватная очередь. Используется в клиентах. Как? Расскажу чуть позже.
    * Вторым аргументом идут флаги. (IPC_CREAT, IPC_EXCL и права доступа к файлу(такие же как и в open())).
        Если хотим создать очередь... Есть 2 варианта:
            1) Если первым аргументом указан IPC_PRIVATE, то указываем просто права доступа.
            2) Если первым аргументом указан ключ, полученный с помощью ftok, указываем флаг IPC_CREAT и права доступа через |.
                Если хотим сделать проверку на существование очереди - указываем еще флаг IPC_EXCL. При уже существующей очереди
                    функция завершится с ошибкой.  
        Если хотим присоединиться к очереди, то не указываем ничего. Передаем 0.
    * В случае успеха возвращаемое значение - id очереди. В случае ошибки вернется -1.

##########################################################################################
Функция int msgctl(int msqid, int cmd, struct ,sqid_ds *buf). Выполняет операции над очередью сообщений.
    * Первый аргумент - id очереди.
    * Второй аргумент - команда на выбор:
        IPC_STAT - Скопировать информацию из структуры данных очереди сообщений, ассоциированных с msqid в структуру 
            с адресом buf (причем, у вызывающего должны быть права на чтение очереди сообщений).
        IPC_SET - Записать значения некоторых элементов структуры msqid_ds , адрес которой указан в buf, в структуру данных 
            из очереди сообщений, обновляя при этом его поле msg_ctime... 
        IPC_RMID - Немедленно удалить очередь сообщений и связанную с ней структуру данных, "разбудив" все процессы, 
            ожидающие записи или чтения этой очереди (при этом функция возвращает ошибку, а переменная errno приобретает значение EIDRM). 
                Вызывающий процесс должен иметь соответствующие (вероятнее всего для root) привилегии или 
                    его действующий идентификатор пользователя должен соответствовать создателю или владельцу очереди сообщений.
    * Третий аргумент - адрес структуры msqid_ds...
    * Возвращаемое значение в случае успеха 0, в случае ошибки -1.

##########################################################################################
Функция int msgsnd(int msqid, struct msgbuf *msgp, size_t msgsz, int msgflg). Для отправки сообщения в очередь.
    Далее цитирую man:
    
    Для того чтобы отправить или получить сообщения, вызывающий процесс создает структуру по такой общей форме:
       struct msgbuf {
               long    mtype;   /* тип сообщения, должен быть > 0 */

               char    mtext[1];        /* содержание сообщения */

       };
    Поле mtext является массивом (или другой структурой), размер которого определяется msgsz, неотрицательным целым значением.
    **То есть мы должны создать свою структуру по данном образцу.
    Сообщения нулевой длины (т.е. без поля mtext) разрешены. Поле mtype должно принимать только положительные целые значения, 
        используемые процессом-получателем для выбора сообщений.
    Вызывающий процесс должен иметь права на запись для отправки данных, а при получении - права на чтение для этой очереди.
    Системный вызов msgsnd добавляет сообщение, указанное параметром msgp, в очередь сообщений, идентификатор которой указывается параметром msqid.
    *В случае успеха возвращает 0, в случае ошибки -1.
            
            
##########################################################################################
Функция ssize_t msgrcv(int msqid, struct msgbuf *msgp, size_t msgsz, long msgtyp, int msgflg). Для чтения из очереди.
    Системный вызов msgrcv записывает сообщение из очереди (идентификатор которой указан в msqid) в буфер msgbuf (находящийся в msgp), удаляя сообщение из очереди.

    Параметр msgsz задает максимальный размер элемента mtext структуры, находящейся по адресу, указанному в аргументе msgp. 
        Если длина текста сообщения больше, чем msgsz, и флаг msgflg установлен в MSG_NOERROR, то текст сообщения будет урезан (а урезанная часть потеряна), 
            иначе сообщение не удаляется из очереди, а системный вызов возвращает ошибку, установив значение errno, равное E2BIG.
    Параметр msgtyp задает тип сообщения следующим образом:
        - если msgtyp равен нулю, то используется первое сообщение из очереди;
        - если msgtyp больше нуля, то из очереди берется первое сообщение типа msgtyp (если только во флаге msgflg нет бита MSG_EXCEPT. 
            В этом случае из очереди берется первое сообщение, тип которого не равен msgtyp).
        - если msgtyp меньше нуля, то из очереди берется первое сообщение со значением, меньшим, чем абсолютное значение msgtyp.
    Параметр msgflg состоит из комбинации следующих флагов:
        - IPC_NOWAIT, который указывает на немедленный возврат из функции, если в очереди нет сообщений необходимого типа. 
            При этом системный вызов возвращает ошибку, устанавливая значение errno равным ENOMSG;
        - MSG_EXCEPT , который используется (если msgtyp больше, чем 0) для чтения первого сообщения, тип которого не равен msgtyp;
        - MSG_NOERROR, используемый для урезания текста сообщения, размер которого больше msgsz байтов.
    Если в очереди нет сообщения необходимого типа, и в msgflg не установлен флаг IPC_NOWAIT, то вызывающий процесс будет заблокирован до тех пор, пока не произойдет одно из следующих событий:
        1) сообщение необходимого типа помещено в очередь;
        2) очередь сообщений удалена из системы (в этом случае системный вызов возвращает ошибку, устанавливая значение errno , равное EIDRM).
        3) вызывающий процесс получает сигнал, который он должен обработать. В этом случае системный вызов возвращает ошибку, устанавливая значение переменной errno , равное EINTR.
    *Возвращаемое значение в случае успеха - количество байт скопированных в поле mtext, в случае ошибки -1.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Общий принцип работы:

    Клиентский процесс отправляет id своей приватной очереди вместе с сообщением запроса в очередь сервера. 
                Сервер извлекает из сообщения запроса этот id и знает кому отправить обратно ответ.
                    Клиент этим временем ждет получить ответ в свою приватную очередь.